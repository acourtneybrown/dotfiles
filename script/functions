# shellcheck shell=bash

# install_updates checks for macOS software updates & installs them
function install_updates() {
  if softwareupdate -l 2>&1 | grep -q "No new software available."; then
    echo "No software updates to install"
  else
    echo "Installing software updates:"
    sudo softwareupdate --install --all
    xcode_license
  fi
}

# xcode_license checks if the Xcode license is agreed to and agree if not.
function xcode_license() {
  if /usr/bin/xcrun clang 2>&1 | grep -q license; then
    if [ -n "${STRAP_INTERACTIVE}" ]; then
      echo "Asking for Xcode license confirmation:"
      sudo xcodebuild -license accept
    else
      abort "Run 'sudo xcodebuild -license' to agree to the Xcode license."
    fi
  fi
}

function escape() {
  printf '%s' "${1//\'/\'}"
}

function abort() {
  echo "!!! ${*}" >&2
  exit 1
}

function is_mac() {
  [ "$(uname -s)" = "Darwin" ]
}

function is_linux() {
  [ "$(uname -s)" = "Linux" ]
}

function sudo_keepalive() {
  # Ask for the administrator password upfront
  sudo -v

  # Keep-alive: update existing `sudo` time stamp until current script has finished
  while true; do
    sudo -n true
    sleep 60
    kill -0 "${$}" || exit
  done 2>/dev/null &
}

function sudo_check_then_alive() {
  # We want to always prompt for sudo password at least once rather than doing
  # root stuff unexpectedly.
  sudo --reset-timestamp

  sudo_keepalive
}

function download_and_verify() {
  local url
  local sha256
  local output
  local tempfile
  local tempout

  url="${1}"
  sha256="${2}"
  output="${3}"
  tempfile=$(mktemp /tmp/sha256.XXXXXX)
  tempout=$(mktemp /tmp/curl.XXXXXX)
  echo "${sha256} -" >"${tempfile}"

  if curl -fLs "${url}" | tee "${tempout}" | sha256sum -c "${tempfile}"; then
    mv "${tempout}" "${output}"
  else
    echo "Hash did not match"
  fi

  rm -f "${tempfile}" "${tempout}"
}

function ensure_brewfile_installed() {
  local brewfile
  if [[ "${#}" -lt 1 ]]; then
    brewfile=Brewfile
  else
    brewfile="${1}"
  fi

  if [[ -f ${brewfile} ]] && is_mac; then
    # We can't control if some packages fail to install, so don't exit out
    set +e
    brew bundle check --file "${brewfile}" >/dev/null 2>&1 || {
      echo "==> Installing Homebrew dependenciesâ€¦"
      # mas signin  # uncomment when https://github.com/mas-cli/mas/issues/164 resolved
      brew bundle --file "${brewfile}"
    }
    set -e
  fi
}

function ensure_command() {
  if [[ "${#}" -ne 1 ]]; then
    abort "called ensure_command with wrong arguments: ${*}"
  elif ! command -v "${1}" >/dev/null; then
    abort "Install ${1} first!"
  fi
}

function enable_pyenv() {
  export PYENV_ROOT="${HOME}/.pyenv"
  export PATH="${PYENV_ROOT}/bin:${PATH}"
  eval "$(pyenv init -)"
}

function enable_goenv() {
  export GOENV_ROOT="${HOME}/.goenv"
  export PATH="${GOENV_ROOT}/bin:${PATH}"
  eval "$(goenv init -)"
}

function enable_jenv() {
  export PATH="${HOME}/.jenv/bin:${PATH}"
  eval "$(jenv init -)"
}

# pipx_install takes a version of Python installed via pyenv & installs a list of pipx packages with that version
function pipx_install() {
  ensure_command "pyenv"

  local to_install
  to_install=${1}
  shift

  local version
  version=$(ensure_pyenv_version "${to_install}")
  local py_bin
  py_bin=$(PYENV_VERSION=${version} pyenv prefix)/bin/python
  for package in "$@"; do
    pipx install "${package}" --python "${py_bin}"
  done
}

function ensure_pyenv_version() {
  ensure_command "pyenv"

  local to_install
  to_install=${1}

  pyenv install --skip-existing "$(pyenv latest --known "${to_install}")"
  pyenv latest "${to_install}"
}

function ensure_goenv_version() {
  ensure_command "goenv"

  local to_install
  to_install=${1}

  goenv install --skip-existing "$(goenv install -l | grep "${to_install}" | tail -1)"
  goenv install -l | grep "${to_install}" | tail -1
}
